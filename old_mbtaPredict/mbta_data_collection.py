import urllib   # urlencode function
import urllib2  # urlopen function (better than urllib version)
import json
import ast
import time
import os.path
from pprint import pprint
from collections import OrderedDict
from datetime import datetime

MBTA_API_KEY = "KE_VanziA0OQ_r_sV6_KIQ"
MBTA_BASE_URL = "http://realtime.mbta.com/developer/api/v2/"

def get_json(url):
    """
    Input: url
    Output: .json string from the url
    """

    #Open the API value of the url and return as .json
    try:
        f = urllib2.urlopen(str(url))
        return json.loads(f.read())
    #returns None if there is a 404 error
    except urllib2.HTTPError:
         return

def fetch_mbta_routes():
    """
    Output: Text file with complete list of routes for which data can be requested through the MBTA API
    """
    query = "routes"
    api_key = "?api_key=%s" % MBTA_API_KEY
    format = "&format=json"

    routes = str(get_json(MBTA_BASE_URL + query + api_key + format))
    f = open('complete_routes.txt','w')
    f.write(routes)
    f.close()

def mbta_route_list():
    """
    From complete_routes.txt generated by fetch_mbta_routes, outputs list of possible mbta route_ids
    Output: List of mbta route_ids
    """
    f = open('complete_routes.txt', 'r')
    complete_routes = ast.literal_eval(f.read())

    #creates list of all route_ids in MBTA system
    subway_route_list = []
    for x in range(len(complete_routes['mode'])):
        if complete_routes['mode'][x]['mode_name'] == 'Subway':
            for y in range(len(complete_routes['mode'][x]['route'])):
                subway_route_list.append(complete_routes['mode'][x]['route'][y]['route_id'])

    #removes duplicates from list and returns
    return list(OrderedDict.fromkeys(subway_route_list))


def fetch_trains_per_route(route_id):
    """
    Input: route_id
    Output: list of mbta vehicles on the inputted route_id 
    """
    query = "predictionsbyroute"
    api_key = "?api_key=%s" % MBTA_API_KEY
    route = "&route=%s" % route_id
    format = "&format=json"
    return get_json(MBTA_BASE_URL + query + api_key + route + format)

def fetch_train_location(vehicle_id):
    """
    Input: vehicle_id
    Output: latitude and longitude of train associated with the inputted vehicle_id
    """

def main():
    """
    Main function of mbta_data_collection
    """
    #refreshes mbta route list, isn't ideal, but simplest implementation at the moment
    fetch_mbta_routes()
    subway_route_list = mbta_route_list()
    #delays for 10 seconds to prevent exceeding api request limit
    time.sleep(10)

    for x in subway_route_list:
        #gets system time, system time is assumed to be in EST/EDT
        year = datetime.now().strftime('%Y')
        month = datetime.now().strftime('%m')
        day = datetime.now().strftime('%d')
        hour = datetime.now().strftime('%H')
        minute = datetime.now().strftime('%M')
        sec = datetime.now().strftime('%S')

        save_path = year + '/' + month + '/' + day + '/'
        file_name = hour + '.' + minute + '.' + sec + '.txt'
        complete_path = save_path + file_name

        train_route = fetch_trains_per_route(x)

        if train_route == None:
            pass
        else:
            #checks if save path exists, creates save path if it doesn't exist
            if os.path.exists(save_path):
                f = open(complete_path, 'a')
                f.write(str(train_route))
                f.close()
                #delays loop for 10 seconds to prevent exceeding api request limit
                time.sleep(10)
            else:
                os.makedirs(save_path)
                f = open(complete_path, 'a')
                f.write(str(train_route))
                f.close()
                #delays loop for 10 seconds to prevent exceeding api request limit
                time.sleep(10)

if __name__ == "__main__":
    while True:
        main()